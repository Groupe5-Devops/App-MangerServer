pipeline {
    agent any

    environment {
        GCP_PROJECT_ID = 'citric-period-433211-i6'
        ARTIFACT_REPO_NAME = 'appmanagercr'
        REGION = 'us-central1' 
        BACK_DOCKER_IMAGE = "${REGION}-docker.pkg.dev/${GCP_PROJECT_ID}/${ARTIFACT_REPO_NAME}/servermanagerback:1.${env.BUILD_NUMBER}"
        FRONT_DOCKER_IMAGE = "${REGION}-docker.pkg.dev/${GCP_PROJECT_ID}/${ARTIFACT_REPO_NAME}/servermanagerfront:1.${env.BUILD_NUMBER}"
        GCP_CREDENTIALS_ID = 'gcrToken' 
        SLACK_CHANNEL = 'pipeline_succes'
        SONAR_URL = 'http://34.136.210.154:9000'
        COMMIT=''
        AUTHOR=''
    }

    stages {
        stage('Checkout') {
            steps {
                script {
                    // git branch: 'dev', url: 'https://github.com/Groupe5-Devops/App-MangerServer.git'
                    checkout scm                   
                    // Capture commit and author details
                    env.COMMIT = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
                    env.AUTHOR = sh(script: "git show -s --format='%an' HEAD", returnStdout: true).trim()
                }
            }
        }
        
        stage('Determine Changes') {
            steps {
                script {
                    def changes = sh(script: "git diff --name-only HEAD~1 HEAD", returnStdout: true).trim()
                    echo "Changed files:\n${changes}"
                    env.BUILD_FRONTEND = changes.contains('Server-UI-Frontend/')
                    env.BUILD_BACKEND = changes.contains('Server-API-Backend/')
                    echo "BUILD_FRONTEND=${env.BUILD_FRONTEND}"
                    echo "BUILD_BACKEND=${env.BUILD_BACKEND}"
                }
            }
        }

        stage('Parallel Tests') {
            parallel {
                stage('Backend Tests') {
                    when {
                        expression { env.BUILD_BACKEND == 'true' }
                    }
                    steps {
                        script {
                            echo "Running backend analysis"
                            // Check if the container is running
                            def containerRunning = sh(script: 'docker ps -q -f name=mysql-test', returnStdout: true).trim()
                            
                            if (containerRunning) {
                                echo "Stopping and removing existing container"
                                sh 'docker stop mysql-test || true'
                                sh 'docker rm mysql-test || true'
                            }
                            // Start a MySQL container for tests
                            sh 'docker run --name mysql-test -e MYSQL_ROOT_PASSWORD=root -e MYSQL_USER=spring -e MYSQL_PASSWORD=boot -e MYSQL_DATABASE=serverdb -p 3307:3306 -d mysql:latest'
                            dir('Server-API-Backend') {
                                sh 'pwd'
                                withMaven(maven: 'M3') {
                                    sh 'mvn test'
                                    sh 'ls target/'
                                }
                                withCredentials([string(credentialsId: 'sonarToken', variable: 'SONAR_TOKEN')]) { 
                                    withMaven(maven: 'M3') {
                                        sh 'mvn clean package sonar:sonar -Dsonar.host.url=${SONAR_URL} -Dsonar.login=${SONAR_TOKEN} -DskipTests'
                                        sh 'ls target/'
                                        sh 'mvn checkstyle:checkstyle'
                                        recordIssues(tools: [checkStyle(pattern: '**/checkstyle-result.xml')])

                                    }
                                }
                            }
                            // Cleanup the MySQL container
                            sh 'docker stop mysql-test'
                            sh 'docker rm mysql-test'

                        }
                    }
                }

                stage('Frontend Tests') {
                    when {
                        expression { env.BUILD_FRONTEND == 'true' }
                    }
                    environment {
                        scannerHome = tool 'sonarScanner'
                    }
                    steps {
                        script {
                            echo "Running frontend analysis"
                            dir('Server-UI-Frontend') {
                                withSonarQubeEnv(credentialsId: 'sonarToken', installationName: 'sonar') {
                                    sh "${scannerHome}/bin/sonar-scanner"
                                }
                            }
                        }
                    }
                }
            }
        }

        stage('Parallel Build') {
            parallel {
                stage('Backend Build') {
                    when {
                        expression { env.BUILD_BACKEND == 'true' }
                    }
                    steps {
                        script {
                            echo "Building backend"

                            dir('Server-API-Backend') {
                                // Build the backend Docker image
                                docker.build("${BACK_DOCKER_IMAGE}")
                            }
                        }
                    }
                }

                stage('Frontend Build') {
                    when {
                        expression { env.BUILD_FRONTEND == 'true' }
                    }
                    steps {
                        script {
                            echo "Building frontend"
                            dir('Server-UI-Frontend') {
                                // Build the frontend Docker image
                                docker.build("${FRONT_DOCKER_IMAGE}")
                            }
                        }
                    }
                }
            }
        }

        stage('Trivy security Scans') {
            when {
                expression {
                    return env.BUILD_BACKEND == 'true' || env.BUILD_FRONTEND == 'true'
                }
            }
            steps {
                script {
                    def imagesToScan = []
                    if (env.BUILD_BACKEND == 'true') {
                        imagesToScan << BACK_DOCKER_IMAGE
                    }
                    if (env.BUILD_FRONTEND == 'true') {
                        imagesToScan << FRONT_DOCKER_IMAGE
                    }
                    def reportFiles = []
                    imagesToScan.each { imageName ->
                        def reportFile = "trivy-report-${imageName.split('/').last()}.txt"
                        echo "Running Trivy scan on ${imageName}"
                        sh """
                            docker run --rm \
                            -v /var/run/docker.sock:/var/run/docker.sock \
                            aquasec/trivy image --exit-code 0 --no-progress ${imageName} > ${reportFile}
                        """
                        reportFiles << reportFile
                    }
                    // Archive all report files
                    archiveArtifacts artifacts: reportFiles.join(',')
                }
            }
        }
        
        stage('Parallel Push') {
            parallel {
                
                stage('Push Backend Image') {
                    when {
                        expression { env.BUILD_BACKEND == 'true' }
                    }
                    steps {
                        script {
                            echo "Pushing backend image"
                            withCredentials([file(credentialsId: GCP_CREDENTIALS_ID, variable: 'GCP_KEY_FILE')]) {
                                sh 'gcloud auth activate-service-account --key-file=${GCP_KEY_FILE}'
                                sh 'gcloud auth configure-docker ${REGION}-docker.pkg.dev --quiet'
                            }
                            docker.image("${BACK_DOCKER_IMAGE}").push()
                        }
                    }
                }
        
                stage('Push Frontend Image') {
                    when {
                        expression { env.BUILD_FRONTEND == 'true' }
                    }
                    steps {
                        script {
                            echo "Pushing frontend image"
                            withCredentials([file(credentialsId: GCP_CREDENTIALS_ID, variable: 'GCP_KEY_FILE')]) {
                                sh 'gcloud auth activate-service-account --key-file=${GCP_KEY_FILE}'
                                sh 'gcloud auth configure-docker ${REGION}-docker.pkg.dev --quiet'
                            }
                            docker.image("${FRONT_DOCKER_IMAGE}").push()
                        }
                    }
                }
            }
        }
        // stage('Push Images') {
        //     when {
        //         anyOf {
        //             expression { env.BUILD_FRONTEND == 'true' }
        //             expression { env.BUILD_BACKEND == 'true' }
        //         }
        //     }
        //     steps {
        //         script {
        //             withCredentials([file(credentialsId: GCP_CREDENTIALS_ID, variable: 'GCP_KEY_FILE')]) {
        //                 sh 'gcloud auth activate-service-account --key-file=${GCP_KEY_FILE}'
        //                 sh 'gcloud auth configure-docker ${REGION}-docker.pkg.dev --quiet'
        //             }
        //             if (env.BUILD_FRONTEND == 'true') {
        //                 docker.image("${FRONT_DOCKER_IMAGE}").push()
        //             }
        //             if (env.BUILD_BACKEND == 'true') {
        //                 docker.image("${BACK_DOCKER_IMAGE}").push()
        //             }
        //         }
        //     }
        // }
      
        stage('Trigger Update Manifest Pipeline') {
            when {
                expression {
                    return env.BUILD_BACKEND == 'true' || env.BUILD_FRONTEND == 'true'
                }
            }
            steps {
                script {
                    build job: 'scrappingmanifest', parameters: [
                        string(name: 'DOCKERTAG', value: "1.${BUILD_NUMBER}"),
                        booleanParam(name: 'BUILD_BACKEND', value: env.BUILD_BACKEND == 'true'),
                        booleanParam(name: 'BUILD_FRONTEND', value: env.BUILD_FRONTEND == 'true')
                    ]
                }
            }
        }
    }

    post {
        always {
            cleanWs()
        }
        success {
            script {
                slackSend channel: SLACK_CHANNEL, color: 'good', message: "Pipeline succeeded:\n *pipeline:* ${env.JOB_NAME} #${env.BUILD_NUMBER} \n*Commit:* ${env.COMMIT}\n*by Author:* ${env.AUTHOR} \n${env.BUILD_URL}"
            }
        }
        failure {
            script {
                slackSend channel: SLACK_CHANNEL, color: 'danger', message: "Pipeline failed: ${env.JOB_NAME} ${env.BUILD_NUMBER} \nCommit: ${env.COMMIT} by ${env.AUTHOR} \n${env.BUILD_URL}"
            }
        }
    }
}
